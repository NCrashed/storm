/**
*   Copyright: Â© 1999-2014 Ladislav Zezula
*   License: Subject to the terms of the MIT license, as written in the included LICENSE file.
*   Authors: Ladislav Zezula <ladik@zezula.net>
*          , ShadowFlare <BlakFlare@hotmail.com>
*          , Daniel Chiamarello <dchiamarello@madvawes.com>
*          , NCrashed <ncrashed@gmail.com>
*/
// Original header
/*****************************************************************************/
/* huffman.h                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Description :                                                             */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of huffman.h                       */
/* 03.05.03  2.00  Lad  Added compression                                    */
/* 08.12.03  2.01  Dan  High-memory handling (> 0x80000000)                  */
/*****************************************************************************/
module storm.huffman;

//-----------------------------------------------------------------------------
// Defines

/// Number of items in the item pool 
enum HUFF_ITEM_COUNT    = 0x203;        
/// Maximum number of quick-link items
enum LINK_ITEM_COUNT    = 0x80;         

//-----------------------------------------------------------------------------
// Structures and classes

/// Input stream for Huffmann decompression
class TInputStream
{
    this(ubyte[] inBuffer)
    {
        this.inBuffer = inBuffer;
    }
    
    /// Gets one bit from input stream
    uint get1Bit()
    {
        uint oneBit = 0;
    
        // Ensure that the input stream is reloaded, if there are no bits left
        if(bitCount == 0)
        {
            // Refill the bit buffer
            bitBuffer = inBuffer[0];
            inBuffer = inBuffer[1 .. $];
            bitCount = 8;
        }
    
        // Copy the bit from bit buffer to the variable
        oneBit = (bitBuffer & 0x01);
        bitBuffer >>= 1;
        bitCount--;
    
        return oneBit;
    }
    
    /// Gets 7 bits from the stream. DOES NOT remove the bits from input stream
    uint peek7Bits()
    {
        uint reloadByte = 0;
    
        // If there is not enough bits to get the value,
        // we have to add 8 more bits from the input buffer
        if(bitCount < 7)
        {
            reloadByte = inBuffer[0];
            inBuffer = inBuffer[1 .. $];
            bitBuffer |= reloadByte << bitCount;
            bitCount += 8;
        }
    
        // Return the first available 7 bits. DO NOT remove them from the input stream
        return (bitBuffer & 0x7F);
    }
    
    /// Gets the whole byte from the input stream.
    uint get8Bits()
    {
        uint reloadByte = 0;
        uint oneByte = 0;
    
        // If there is not enough bits to get the value,
        // we have to add 8 more bits from the input buffer
        if(bitCount < 8)
        {
            reloadByte = inBuffer[0];
            inBuffer = inBuffer[1 .. $];
            bitBuffer |= reloadByte << bitCount;
            bitCount += 8;
        }
    
        // Return the lowest 8 its
        oneByte = (bitBuffer & 0xFF);
        bitBuffer >>= 8;
        bitCount -= 8;
        return oneByte;
    }
    
    void skipBits(uint bitsToSkip)
    {
        uint reloadByte = 0;
    
        // If there is not enough bits in the buffer,
        // we have to add 8 more bits from the input buffer
        if(bitCount < bitsToSkip)
        {
            reloadByte = inBuffer[0];
            inBuffer = inBuffer[1 .. $];
            bitBuffer |= reloadByte << bitCount;
            bitCount += 8;
        }
    
        // Skip the remaining bits
        bitBuffer >>= bitsToSkip;
        bitCount -= bitsToSkip;
    }
 
    private
    {
        /// Current position in the the input buffer
        ubyte[] inBuffer;         
        /// Input bit buffer
        uint bitBuffer;     
        /// Number of bits remaining in 'dwBitBuff'
        uint bitCount;
    }
}
 

/// Output stream for Huffmann compression
class TOutputStream
{
    this(ubyte[] outBuffer)
    {
        this.outBuffer = outBuffer;
    }
    
    void putBits(uint value, uint nBitCount)
    {
        bitBuffer |= (value << bitCount);
        bitCount += nBitCount;
     
        // Flush completed bytes
        while(bitCount >= 8)
        {
            if(outBuffer.length > 0)
            {
                outBuffer[0] = cast(ubyte)bitBuffer;
                outBuffer = outBuffer[1 .. $];
            }
            
            bitBuffer >>= 8;
            bitCount -= 8;
        }
    }
    
    void flush()
    {
        while(bitCount != 0)
        {
            if(outBuffer.length > 0)
            {
                outBuffer[0] = cast(ubyte)bitBuffer;
                outBuffer = outBuffer[1 .. $];
            }
    
            bitBuffer >>= 8;
            bitCount -= ((bitCount > 8) ? 8 : bitCount);
        }
    }
 
    private
    {
        /// Current position in the output buffer
        ubyte[] outBuffer;        
        /// Bit buffer
        uint bitBuffer;             
        /// Number of bits in the bit buffer
        uint bitCount;
    }              
}

enum InsertPoint
{
    After = 1,
    Before = 2
}

/// Huffmann tree item
class THTreeItem
{
    void removeItem()
    {
        if(next !is null)
        {
            prev.next = next;
            next.prev = prev;
            next = prev = null;
        }
    }
 
    /// Pointer to lower-weight tree item
    THTreeItem  next;                
    /// Pointer to higher-weight item
    THTreeItem  prev;                
    /// 08 - Decompressed byte value (also index in the array)
    uint  decompressedValue;          
    /// 0C - Weight
    uint  weight;                     
    /// 10 - Pointer to parent item (null if none)
    THTreeItem  parent;              
    /// 14 - Pointer to the child with lower-weight child ("left child")
    THTreeItem  childLo;             
}


/// Structure used for quick navigating in the huffmann tree.
/// Allows skipping up to 7 bits in the compressed stream, thus
/// decompressing a bit faster. Sometimes it can even get the decompressed
/// byte directly.
struct TQuickLink
{      
    /// If greater than THuffmannTree::MinValidValue, the entry is valid
    uint validValue;            
    //// Number of bits that are valid for this item link
    uint validBits;             
    union
    {
        /// Pointer to the item within the Huffmann tree
        THTreeItem item;            
        /// Value for direct decompression
        uint decompressedValue; 
    }
}
                                           

/// Structure for Huffman tree (Size 0x3674 bytes). Because I'm not expert
/// for the decompression, I do not know actually if the class is really a Hufmann
/// tree. If someone knows the decompression details, please let me know
class THuffmannTree
{
    public:
    
    this(bool compression)
    {
        /// TODO: Obsolete, delete this!!
        first = last = listHead();
     
        minValidValue = 1;
        itemsUsed = 0;
        
        foreach(ref item; itemBuffer)
        {
            item = new THTreeItem;
        }
    }

    void linkTwoItems(THTreeItem item1, THTreeItem item2)
    {
        item2.next = item1.next;
        item2.prev = item1.next.prev;
        item1.next.prev = item2;
        item1.next = item2;
    }
    
    /// Inserts item into the tree (?)
    void insertItem(THTreeItem item, InsertPoint insertPoint, THTreeItem item2)
    {
        // Remove the item from the tree
        item.removeItem();
     
        if(item2 is null)
            item2 = listHead();
    
        final switch(insertPoint)
        {
            case InsertPoint.After:
                linkTwoItems(item2, item);
                return;
           
            case InsertPoint.Before:
                item.next = item2;             // Set next item (or pointer to pointer to first item)
                item.prev = item2.prev;        // Set prev item (or last item in the tree)
                item2.prev.next = item;
                item2.prev = item;             // Set the next/last item
                return;
        }
    }

    THTreeItem findHigherOrEqualItem(THTreeItem item, uint weight)
    {
        // Parse all existing items
        if(item !is null)
        {
            while(item != listHead)
            {
                if(item.weight >= weight)
                    return item;
    
                item = item.prev;
            }
        }
    
        // If not found, we just get the first item
        return listHead;
    }
    
    THTreeItem createNewItem(uint decompressedValue, uint weight, InsertPoint insertPoint)
    {
        THTreeItem newItem;
    
        // Allocate new item from the item pool
        newItem = itemBuffer[itemsUsed++];
    
        // Insert this item to the top of the tree
        insertItem(newItem, insertPoint, null);
    
        // Fill the rest of the item
        newItem.decompressedValue = decompressedValue;
        newItem.weight = weight;
        newItem.parent = null;
        newItem.childLo = null;
        return newItem;
    }

    uint fixupItemPosByWeight(THTreeItem newItem, uint maxWeight)
    {
        THTreeItem higherItem;
    
        if(newItem.weight < maxWeight)
        {
            // Find an item that has higher weight than this one
            higherItem = findHigherOrEqualItem(last, newItem.weight);
    
            // Remove the item and put it to the new position
            newItem.removeItem();
            linkTwoItems(higherItem, newItem);
        }
        else
        {
            maxWeight = newItem.weight;
        }
    
        // Return the (updated) maximum weight
        return maxWeight;
    }
    
    void buildTree(uint compressionType)
    {
        THTreeItem newItem;
        THTreeItem childLo;
        THTreeItem childHi;
        uint maxWeight;                     // [ESP+10] - The greatest character found in table
     
        // Clear all pointers in HTree item array
        itemsByByte[] = null;
        maxWeight = 0;
     
        // Ensure that the compression type is in range
        assert((compressionType & 0x0F) <= 0x08);
        auto weightTable  = weightTables[compressionType & 0x0F];
     
        // Build the linear list of entries that is sorted by byte weight
        for(uint i = 0; i < 0x100; i++)
        {
            // Skip all the bytes which are zero.
            if(weightTable[i] != 0)
            {
                // Create new tree item
                itemsByByte[i] = newItem = createNewItem(i, weightTable[i], InsertPoint.After);
    
                // We need to put the item to the right place in the list
                maxWeight = fixupItemPosByWeight(newItem, maxWeight);
            }
        }
     
        // Insert termination entries at the end of the list
        itemsByByte[0x100] = createNewItem(0x100, 1, InsertPoint.Before);
        itemsByByte[0x101] = createNewItem(0x101, 1, InsertPoint.Before);
     
        // Now we need to build the tree. We start at the last entry
        // and go backwards to the first one
        childLo = last;
    
        // Work as long as both children are valid
        // childHi is child with higher weight, childLo is the one with lower weight
        while(childLo != listHead())
        {
            // Also get and verify the higher-weight child
            childHi = childLo.prev;
            if(childHi == listHead())
                break;
    
            // Create new parent item for the children
            newItem = createNewItem(0, childHi.weight + childLo.weight, InsertPoint.After);
    
            // Link both child items to their new parent
            childLo.parent = newItem;
            childHi.parent = newItem;
            newItem.childLo = childLo;
    
            // Fixup the item's position by its weight
            maxWeight = fixupItemPosByWeight(newItem, maxWeight);
    
            // Get the previous lower-weight child
            childLo = childHi.prev;
        }
    
        // Initialize the MinValidValue to 1, which invalidates all quick-link items
        minValidValue = 1;
    }

    void incWeightsAndRebalance(THTreeItem item)
    {
        THTreeItem higherItem;           // A previous item with greater or equal weight
        THTreeItem childHi;              // The higher-weight child
        THTreeItem childLo;              // The lower-weight child
        THTreeItem parent;
     
        // Climb up the tree and increment weight of each tree item
        for(; item !is null; item = item.parent)
        {
            // Increment the item's weight
            item.weight++;
    
            // Find a previous item with equal or greater weight, which is not equal to this item
            higherItem = findHigherOrEqualItem(item.prev, item.weight);
            childHi = higherItem.next;
    
            // If the item is not equal to the tree item, we need to rebalance the tree
            if(childHi != item)
            {
                // Move the previous item to the RIGHT from the given item
                childHi.removeItem();
                linkTwoItems(item, childHi);
                
                // Move the given item AFTER the greater-weight tree item
                item.removeItem();
                linkTwoItems(higherItem, item);
         
                // We need to maintain the tree so that childHi.Weight is >= childLo.Weight.
                // Rebalance the tree accordingly.
                childLo = childHi.parent.childLo;
                parent = item.parent;
                if(parent.childLo == item)
                    parent.childLo = childHi;
                if(childLo == childHi)
                    childHi.parent.childLo = item;
                parent = item.parent;
                item.parent = childHi.parent;
                childHi.parent = parent;
    
                // Increment the global valid value. This invalidates all quick-link items.
                minValidValue++;
            }
        }
    }
    
    void insertNewBranchAndRebalance(uint value1, uint value2)
    {
        THTreeItem lastItem = last;
        THTreeItem childHi;
        THTreeItem childLo;
    
        // Create higher-weight child
        childHi = createNewItem(value1, lastItem.weight, InsertPoint.Before);
        childHi.parent = lastItem;
        itemsByByte[value1] = childHi;
    
        // Create lower-weight child
        childLo = createNewItem(value2, 0, InsertPoint.Before);
        childLo.parent = lastItem;
        lastItem.childLo = childLo;
        itemsByByte[value2] = childLo;
    
        incWeightsAndRebalance(childLo);
    }

    void encodeOneByte(TOutputStream os, THTreeItem item)
    {
        THTreeItem parent = item.parent;
        uint bitBuffer = 0;
        uint bitCount = 0;
    
        // Put 1's as long as there is parent
        while(parent !is null)
        {
            // Fill the bit buffer
            bitBuffer = (bitBuffer << 1) | ((parent.childLo != item) ? 1 : 0);
            bitCount++;
    
            // Move to the parent
            item = parent;
            parent = parent.parent;
        }
    
        // Write the bits to the output stream
        os.putBits(bitBuffer, bitCount);

    }
    
    uint decodeOneByte(TInputStream _is)
    {
        THTreeItem itemLink = null;
        THTreeItem item;
        uint itemLinkIndex;
        uint bitCount = 0;
    
        // Check for the end of the input stream
        if(_is.inBuffer.length == 0 && _is.bitCount < 7)
            return 0x1FF;
    
        // Get the eventual quick-link index
        itemLinkIndex = _is.peek7Bits();
        
        // Is the quick-link item valid?
        if(quickLinks[itemLinkIndex].validValue > minValidValue)
        {
            // If that item needs less than 7 bits, we can get decompressed value directly
            if(quickLinks[itemLinkIndex].validBits <= 7)
            {
                _is.skipBits(quickLinks[itemLinkIndex].validBits);
                return quickLinks[itemLinkIndex].decompressedValue;
            }
    
            // Otherwise we cannot get decompressed value directly
            // but we can skip 7 levels of tree parsing
            item = quickLinks[itemLinkIndex].item;
            _is.skipBits(7);
        }
        else
        {
            // Just a sanity check
            if(first == listHead)
                return 0x1FF;
    
            // We don't have the quick-link item, we need to parse the tree from its root
            item = first;
        }
    
        // Step down the tree until we find a terminal item
        while(item.childLo !is null)
        {
            // If the next bit in the compressed stream is set, we get the higher-weight
            // child. Otherwise, get the lower-weight child.
            item = _is.get1Bit() ? item.childLo.prev : item.childLo;
            bitCount++;
    
            // If the number of loaded bits reached 7,
            // remember the current item for storing into quick-link item array
            if(bitCount == 7)
                itemLink = item;
        }
    
        // If we didn't get the item from the quick-link array,
        // set the entry in it
        if(quickLinks[itemLinkIndex].validValue < minValidValue)
        {
            // If the current compressed byte was more than 7 bits,
            // set a quick-link item with pointer to tree item
            if(bitCount > 7)
            {
                quickLinks[itemLinkIndex].validValue = minValidValue;
                quickLinks[itemLinkIndex].validBits = bitCount;
                quickLinks[itemLinkIndex].item = itemLink;
            }
            else
            {
                // Limit the quick-decompress item to lower amount of bits
                itemLinkIndex &= (0xFFFFFFFF >> (32 - bitCount));
                while(itemLinkIndex < LINK_ITEM_COUNT)
                {
                    // Fill the quick-decompress item
                    quickLinks[itemLinkIndex].validValue = minValidValue;
                    quickLinks[itemLinkIndex].validBits  = bitCount;
                    quickLinks[itemLinkIndex].decompressedValue = item.decompressedValue;
    
                    // Increment the index
                    itemLinkIndex += (1 << bitCount);
                }
            }
        }
    
        // Return the decompressed value from the found item
        return item.decompressedValue;
    }

    size_t compress(TOutputStream os, ubyte[] inBuffer, int compressionType)
    {
        ubyte[] outBuff = os.outBuffer;
        ubyte inputByte;
     
        buildTree(compressionType);
        isCmp0 = (compressionType == 0);
    
        // Store the compression type into output buffer
        os.putBits(compressionType, 8);
     
        // Process the entire input buffer
        while(inBuffer.length > 0)
        {
            // Get the (next) byte from the input buffer
            inputByte = inBuffer[0];
            inBuffer = inBuffer[1 .. $];
            
            // Do we have an item for such input value?
            if(itemsByByte[inputByte] is null)
            {
                // Encode the relationship
                encodeOneByte(os, itemsByByte[0x101]);
     
                // Store the loaded byte into output stream
                os.putBits(inputByte, 8);
     
                insertNewBranchAndRebalance(last.decompressedValue, inputByte);
    
                if(isCmp0)
                {
                    incWeightsAndRebalance(itemsByByte[inputByte]);
                    continue;
                }
      
                incWeightsAndRebalance(itemsByByte[inputByte]);
            }
            else
            {
                encodeOneByte(os, itemsByByte[inputByte]);
            }
     
            if(isCmp0)
            {
                incWeightsAndRebalance(itemsByByte[inputByte]);
            }
        }
     
        // Put the termination mark to the compressed stream
        encodeOneByte(os, itemsByByte[0x100]);
     
        // Flush the remaining bits
        os.flush();
        return cast(size_t)(os.outBuffer.ptr - outBuff.ptr);
    }
    
    /// Decompression using Huffman tree (1500E450)
    size_t decompress(ubyte[] outBuffer, TInputStream _is)
    {
        auto savedOutBuffer = outBuffer;
        uint decompressedValue = 0;
        uint compressionType = 0;
       
        // Test the output length. Must not be NULL.
        if(outBuffer.length == 0)
            return 0;
     
        // Get the compression type from the input stream
        compressionType = _is.get8Bits();
        isCmp0 = (compressionType == 0) ? 1 : 0;
     
        // Build the Huffman tree
        buildTree(compressionType);    
     
        // Process the entire input buffer until end of the stream
        while((decompressedValue = decodeOneByte(_is)) != 0x100)
        {
            // Did an error occur?
            if(decompressedValue == 0x1FF)          // An error occurred
                return 0;
    
            // Huffman tree needs to be modified
            if(decompressedValue == 0x101)
            {
                // The decompressed byte is stored in the next 8 bits
                decompressedValue = _is.get8Bits();
    
                insertNewBranchAndRebalance(last.decompressedValue, decompressedValue);
    
                if(isCmp0 == 0)
                    incWeightsAndRebalance(itemsByByte[decompressedValue]);
            }
     
            // A byte successfully decoded - store it in the output stream
            outBuffer[0] = cast(ubyte)decompressedValue;
            outBuffer = outBuffer[1 .. $];
            if(outBuffer.length == 0)
                break;
     
            if(isCmp0)
            {
                incWeightsAndRebalance(itemsByByte[decompressedValue]);
            }
        }
     
        return cast(size_t)(outBuffer.ptr - savedOutBuffer.ptr);
    }
 
    private
    {
        /// A virtual tree item that represents the head of the item list
        THTreeItem listHead()
        {
            return cast(THTreeItem)(&first);
        }
    }
    private
    {
        /// Buffer for tree items. Allocated once
        THTreeItem[HUFF_ITEM_COUNT] itemBuffer;   
        /// Number of tree items used from ItemBuffer
        size_t itemsUsed;                         
     
        // Head of the linear item list
        /// Pointer to the highest weight item
        THTreeItem first;                        
        /// Pointer to the lowest weight item
        THTreeItem last;                         
    
        /// Array of item pointers, one for each possible byte value
        THTreeItem[0x102]            itemsByByte; 
        /// Array of quick-link items
        TQuickLink[LINK_ITEM_COUNT]  quickLinks;  
        
        /// A minimum value of TQDecompress::ValidValue to be considered valid
        uint minValidValue;
        /// true if compression type 0
        bool isCmp0;                        
    }
}

private:

//-----------------------------------------------------------------------------
// Table of byte-to-weight values

/// Table for (de)compression. Every compression type has 258 entries
immutable ubyte[] byteToWeight_00 =
[
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00
];

/// Data for compression type 0x01
immutable ubyte[] byteToWeight_01 =
[
    0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
    0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
    0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
    0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
    0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
    0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
    0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
    0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
    0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
    0x00, 0x00
];
   
/// Data for compression type 0x02
immutable ubyte[] byteToWeight_02 =
[
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
    0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
    0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
    0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
    0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
    0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
];
   
/// Data for compression type 0x03
immutable ubyte[] byteToWeight_03 =
[
    0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
    0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
    0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
    0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
    0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
    0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
    0x00, 0x00
];
   
/// Data for compression type 0x04
immutable ubyte[] byteToWeight_04 =
[
    0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
];
   
/// Data for compression type 0x05
immutable ubyte[] byteToWeight_05 =
[
    0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
    0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
    0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
    0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
];
   
/// Data for compression type 0x06
immutable ubyte[] byteToWeight_06 =
[
    0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
];
   
/// Data for compression type 0x07
immutable ubyte[] byteToWeight_07 =
[
    0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
];
   
/// Data for compression type 0x08
immutable ubyte[] byteToWeight_08 =
[
    0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
    0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
    0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
];

immutable ubyte[][] weightTables =
[
    byteToWeight_00,
    byteToWeight_01,
    byteToWeight_02,
    byteToWeight_03,
    byteToWeight_04,
    byteToWeight_05,
    byteToWeight_06,
    byteToWeight_07,
    byteToWeight_08
];

//----------------------------------------------------------------------------- 
// Debug/diagnostics

debug
{
    void dumpHuffmannTree(THTreeItem item)
    {
        THTreeItem childLo;                          // Item with the lower weight
        THTreeItem childHi;                          // Item with the higher weight
    
        // Get the lower-weight branch
        childLo = item.childLo;
        if(childLo !is null)
        {
            // Get the higher-weight branch
            childHi = childLo.prev;
    
            // Parse the lower-weight branch
            dumpHuffmannTree(childHi);
            dumpHuffmannTree(childLo);
        }
    }
}